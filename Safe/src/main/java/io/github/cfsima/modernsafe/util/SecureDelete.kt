package io.github.cfsima.modernsafe.util

import android.util.Log
import estreamj.ciphers.trivium.Trivium
import estreamj.framework.ICipher
import estreamj.framework.ESJException
import java.io.File
import java.io.FileNotFoundException
import java.io.IOException
import java.io.RandomAccessFile
import java.nio.channels.FileChannel
import java.security.SecureRandom

/**
 * Secure file delete.
 *
 * @author Peli
 */
object SecureDelete {
    private const val TAG = "SecureDelete"

    /**
     * Securely delete a file.
     * <p/>
     * Currently, there is only 1 pass that overwrites the file first
     * with a random bit stream generated by Trivium.
     *
     * @param file
     * @return true if this File was deleted, false otherwise.
     */
    fun delete(file: File): Boolean {
        if (file.exists()) {
            val random = SecureRandom()
            val tri = Trivium()

            try {
                RandomAccessFile(file, "rw").use { raf ->
                    val channel = raf.channel
                    val buffer = channel.map(
                        FileChannel.MapMode.READ_WRITE, 0, raf.length()
                    )

                    val key = ByteArray(10)
                    val nonce = ByteArray(10)
                    random.nextBytes(key)
                    random.nextBytes(nonce)

                    tri.setupKey(
                        ICipher.MODE_DECRYPT,
                        key, 0
                    )
                    tri.setupNonce(nonce, 0)

                    val buffersize = 1024
                    val bytes = ByteArray(1024)

                    // overwrite with random numbers
                    while (buffer.hasRemaining()) {
                        var max = buffer.limit() - buffer.position()
                        if (max > buffersize) {
                            max = buffersize
                        }
                        //random.nextBytes(bytes);

                        tri.process(
                            bytes, 0,
                            bytes, 0, max
                        )

                        buffer.put(bytes, 0, max)
                    }
                    buffer.force()
                    buffer.rewind()
                }
            } catch (e: FileNotFoundException) {
                Log.d(TAG, "FileNotFoundException", e)
            } catch (e: IOException) {
                Log.d(TAG, "IOException", e)
            } catch (e: ESJException) {
                Log.d(TAG, "ESJException", e)
            }
            return file.delete()
        }
        return false
    }
}
