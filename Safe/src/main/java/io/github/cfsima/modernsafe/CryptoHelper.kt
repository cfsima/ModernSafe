/*
 * Copyright 2007-2008 Steven Osborn
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.github.cfsima.modernsafe

import android.content.ContentResolver
import android.content.Context
import android.net.Uri
import android.os.Environment
import android.util.Log
import estreamj.ciphers.trivium.Trivium
import estreamj.framework.ESJException
import io.github.cfsima.modernsafe.util.SecureDelete
import java.io.ByteArrayInputStream
import java.io.File
import java.io.FileInputStream
import java.io.FileNotFoundException
import java.io.FileOutputStream
import java.io.IOException
import java.io.InputStream
import java.io.OutputStream
import java.security.DigestInputStream
import java.security.InvalidAlgorithmParameterException
import java.security.InvalidKeyException
import java.security.MessageDigest
import java.security.NoSuchAlgorithmException
import java.security.NoSuchProviderException
import java.security.SecureRandom
import java.security.spec.InvalidKeySpecException
import javax.crypto.BadPaddingException
import javax.crypto.Cipher
import javax.crypto.IllegalBlockSizeException
import javax.crypto.KeyGenerator
import javax.crypto.NoSuchPaddingException
import javax.crypto.SecretKey
import javax.crypto.SecretKeyFactory
import javax.crypto.spec.PBEKeySpec
import javax.crypto.spec.PBEParameterSpec

/**
 * Crypto helper class.
 *
 * Basic crypto class that uses Bouncy Castle Provider to
 * encrypt/decrypt data using PBE (Password Based Encryption) via
 * 128Bit AES.
 *
 * @author Steven Osborn - http://steven.bitsetters.com
 */
class CryptoHelper {

    private val algorithmMedium = "PBEWithMD5And128BitAES-CBC-OpenSSL"
    private val algorithmStrong = "PBEWithSHA1And256BitAES-CBC-BC"
    private var algorithm = ""

    // Status of the last encrypt/decrypt
    var status: Boolean = false
        private set

    /**
     * Session key for content provider.
     */
    // This should be the same session key as is used in CryptoContentProvider.
    val currentSessionKey: String?
        get() = if (CryptoContentProvider.ch != null) {
            CryptoContentProvider.ch.sessionKey
        } else null

    private var sessionKey: String? = null

    /**
     * Constructor which defaults to a medium encryption level.
     */
    init {
        // initialize(EncryptionMedium)
    }

    /**
     * Constructor which allows the specification of the encryption level.
     *
     * @param strength encryption strength
     * @param salt     salt to be used
     */
    @Throws(CryptoHelperException::class)
    fun init(strength: Int, salt: String?) {
        try {
            setSalt(salt)
            initialize(strength)
        } catch (e: CryptoHelperException) {
            e.printStackTrace()
            throw e
        }
    }

    /**
     * Initialize the class.  Sets the encryption level for the instance
     * and generates the secret key factory.
     *
     * @param strength
     */
    private fun initialize(strength: Int) {
        algorithm = when (strength) {
            EncryptionMedium -> algorithmMedium
            EncryptionStrong -> algorithmStrong
            else -> algorithmMedium
        }
        pbeParamSpec = PBEParameterSpec(salt, count)
        try {
            keyFac = SecretKeyFactory.getInstance(algorithm, "BC")
        } catch (e: NoSuchAlgorithmException) {
            Log.e(TAG, "CryptoHelper(): $e")
        } catch (e: NoSuchProviderException) {
            Log.e(TAG, "CryptoHelper(): $e")
        }
    }

    /**
     * Set the password to be used as an encryption key
     *
     * @param pass - might be a user-entered key, or one generated by generateMasterKey.
     * @throws Exception
     */
    fun setPassword(pass: String?) {
        if (debug) {
            Log.d(TAG, "setPassword($pass)")
        }
        if (pass == null) {
            return
        }
        password = pass
        pbeKeySpec = PBEKeySpec(password!!.toCharArray())
        try {
            pbeKey = keyFac!!.generateSecret(pbeKeySpec)
            pbeCipher = Cipher.getInstance(algorithm, "BC")
        } catch (e: Exception) {
            Log.e(TAG, "setPassword(): $e")
        }

        // Every time we set a new password, also the session key changes:
        sessionKey = createNewSessionKey()
    }

    @Throws(CryptoHelperException::class)
    private fun setSalt(saltIn: String?) {
        if (saltIn == null) {
            val msg = "Salt must not be null."
            throw CryptoHelperException(msg)
        }
        val byteSaltIn = hexStringToBytes(saltIn)
        if (byteSaltIn.size != 8) {
            val msg = "Salt must be 8 bytes in length."
            throw CryptoHelperException(msg)
        }
        salt = byteSaltIn
        if (debug) {
            Log.d(TAG, "setSalt: salt=" + toHexString(salt!!))
        }
    }

    /**
     * Creates a new random session key
     *
     * @return
     */
    private fun createNewSessionKey(): String {
        return try {
            // simply create a new salt:
            generateSalt()
        } catch (e: NoSuchAlgorithmException) {
            "12345" // better than nothing... :-/
        }
    }

    /**
     * encrypt a string
     *
     * @param plaintext
     * @return encrypted String
     * @throws Exception
     */
    @Throws(CryptoHelperException::class)
    fun encrypt(plaintext: String?): String {
        status = false // assume failure
        if (password == null) {
            val msg = "Must call setPassword before running encrypt."
            throw CryptoHelperException(msg)
        }
        if (salt == null) {
            val msg = "Must call setSalt before running encrypt."
            throw CryptoHelperException(msg)
        }
        var ciphertext = ByteArray(0)
        if (plaintext == null) {
            return ""
        }
        try {
            pbeCipher!!.init(Cipher.ENCRYPT_MODE, pbeKey, pbeParamSpec)
            ciphertext = pbeCipher!!.doFinal(plaintext.toByteArray())
            status = true
        } catch (e: Exception) {
            Log.e(TAG, "encrypt(): $e")
        }
        return toHexString(ciphertext)
    }

    /**
     * unencrypt previously encrypted string
     *
     * @param ciphertext
     * @return decrypted String
     * @throws Exception
     */
    @Throws(CryptoHelperException::class)
    fun decrypt(ciphertext: String?): String {
        status = false // assume failure
        if (password == null) {
            val msg = "Must call setPassword before running decrypt."
            throw CryptoHelperException(msg)
        }
        if (salt == null) {
            val msg = "Must call setSalt before running decrypt."
            throw CryptoHelperException(msg)
        }
        if (ciphertext.isNullOrEmpty()) {
            return ""
        }
        val byteCiphertext = hexStringToBytes(ciphertext!!)
        var plaintext = ByteArray(0)
        try {
            pbeCipher!!.init(Cipher.DECRYPT_MODE, pbeKey, pbeParamSpec)
            plaintext = pbeCipher!!.doFinal(byteCiphertext)
            status = true
        } catch (e: Exception) {
            Log.e(TAG, "decrypt(): $e")
        }
        return String(plaintext)
    }

    /**
     * encrypt a string using a random session key
     *
     * @param plaintext
     * @return encrypted String
     * @throws Exception
     * @author Peli
     */
    @Throws(CryptoHelperException::class)
    fun encryptWithSessionKey(plaintext: String): String {
        if (debug) {
            Log.i(TAG, "Encrypt with session key")
        }
        status = false // assume failure
        if (password == null) {
            val msg = "Must call setPassword before runing encrypt."
            throw CryptoHelperException(msg)
        }
        var cipherSessionKey = ByteArray(0)
        var ciphertext = ByteArray(0)

        // First create a session key
        var sessionKey: SecretKey? = null
        var sessionKeyEncoded: ByteArray? = null
        var sessionKeyString: String? = null
        try {
            val keygen = KeyGenerator.getInstance("AES")
            keygen.init(256) // needs 96 bytes
            //keygen.init(128); // needs 64 bytes
            sessionKey = keygen.generateKey()
            sessionKeyEncoded = sessionKey.encoded
            sessionKeyString = String(sessionKeyEncoded)
        } catch (e: NoSuchAlgorithmException) {
            Log.e(TAG, "generateMasterKey(): $e")
        }

        // Convert this to a Pbe key
        val sessionPbeKeySpec = PBEKeySpec(sessionKeyString!!.toCharArray())
        var sessionPbeKey: SecretKey? = null
        try {
            sessionPbeKey = keyFac!!.generateSecret(sessionPbeKeySpec)
        } catch (e: InvalidKeySpecException) {
            Log.e(TAG, "setPassword(): $e")
        }

        // Encrypt the session key using the master key
        try {
            pbeCipher!!.init(Cipher.ENCRYPT_MODE, pbeKey, pbeParamSpec)
            cipherSessionKey = pbeCipher!!.doFinal(sessionKeyEncoded)
        } catch (e: Exception) {
            Log.e(TAG, "encryptWithSessionKey(): $e")
        }

        // Now encrypt the text using the session key
        try {
            pbeCipher!!.init(Cipher.ENCRYPT_MODE, sessionPbeKey, pbeParamSpec)
            ciphertext = pbeCipher!!.doFinal(plaintext.toByteArray())
            status = true
        } catch (e: Exception) {
            Log.e(TAG, "encryptWithSessionKey2(): $e")
        }
        val stringCipherVersion = "A"
        val stringCipherSessionKey = toHexString(cipherSessionKey)
        val stringCiphertext = toHexString(ciphertext)
        if (debug) {
            Log.i(TAG, "Length: " + stringCipherSessionKey.length + ", " + stringCipherSessionKey)
        }
        return stringCipherVersion + stringCipherSessionKey + stringCiphertext
    }

    /**
     * unencrypt encrypted string previously encrypted with
     * encryptWithSessionKey()
     *
     * @param ciphertext
     * @return decrypted String
     * @throws Exception
     * @author Peli
     */
    @Throws(CryptoHelperException::class)
    fun decryptWithSessionKey(ciphertext: String?): String {
        var ciphertext = ciphertext
        status = false // assume failure
        if (password == null) {
            val msg = "Must call setPassword before running decrypt."
            throw CryptoHelperException(msg)
        }
        if (ciphertext.isNullOrEmpty()) {
            return ""
        }
        var cipherVersion: String? = null
        var cipherSessionKey: String? = null

        // Split cipher into session key and text
        try {
            cipherVersion = ciphertext!!.substring(0, 1)
            if (cipherVersion == "A") {
                cipherSessionKey = ciphertext.substring(1, 97) // 64 if init(128) had been chosen
                ciphertext = ciphertext.substring(97)
            } else {
                Log.e(TAG, "Unknown cipher version$cipherVersion")
                return ""
            }
        } catch (e: IndexOutOfBoundsException) {
            Log.e(TAG, "Invalid ciphertext (with session key)")
            return ""
        }

        // Decrypt the session key
        val byteCipherSessionKey = hexStringToBytes(cipherSessionKey!!)
        var byteSessionKey = ByteArray(0)
        try {
            pbeCipher!!.init(Cipher.DECRYPT_MODE, pbeKey, pbeParamSpec)
            byteSessionKey = pbeCipher!!.doFinal(byteCipherSessionKey)
            status = true
        } catch (e: Exception) {
            Log.e(TAG, "decrypt(): $e")
        }

        // Convert the session key into a Pbe key
        val stringSessionKey = String(byteSessionKey)
        val sessionPbeKeySpec = PBEKeySpec(stringSessionKey.toCharArray())
        var sessionPbeKey: SecretKey? = null
        try {
            sessionPbeKey = keyFac!!.generateSecret(sessionPbeKeySpec)
        } catch (e: InvalidKeySpecException) {
            Log.e(TAG, "setPassword(): $e")
        }

        // Use the session key to decrypt the text
        val byteCiphertext = hexStringToBytes(ciphertext!!)
        var plaintext = ByteArray(0)
        try {
            pbeCipher!!.init(Cipher.DECRYPT_MODE, sessionPbeKey, pbeParamSpec)
            plaintext = pbeCipher!!.doFinal(byteCiphertext)
            status = true
        } catch (e: Exception) {
            Log.e(TAG, "decrypt(): $e")
        }
        return String(plaintext)
    }

    /**
     * encrypt a file using a random session key
     *
     * @param contentResolver is used to be able to read the stream
     * @param fileUri         is the stream or file to read from
     * @return Uri to the created plaintext file
     * @throws Exception
     * @author Peli
     */
    @Throws(CryptoHelperException::class)
    fun encryptFileWithSessionKey(contentResolver: ContentResolver, fileUri: Uri): Uri? {
        if (debug) {
            Log.d(TAG, "Encrypt with session key")
        }
        status = false // assume failure
        if (password == null) {
            val msg = "Must call setPassword before runing encrypt."
            throw CryptoHelperException(msg)
        }
        var outputPath = ""
        try {
            val `is`: InputStream
            if (fileUri.scheme == "file") {
                `is` = FileInputStream(fileUri.path)
                outputPath = fileUri.path + OISAFE_EXTENSION
            } else {
                `is` = contentResolver.openInputStream(fileUri)!!
                outputPath = getTemporaryFileName()
            }
            val os = FileOutputStream(outputPath)
            var cipherSessionKey = ByteArray(0)

            // First create a session key
            var sessionKey: SecretKey? = null
            var sessionKeyEncoded: ByteArray? = null
            try {
                val keygen = KeyGenerator.getInstance("AES")
                keygen.init(256) // needs 96 bytes
                //keygen.init(128); // needs 64 bytes
                sessionKey = keygen.generateKey()
                sessionKeyEncoded = sessionKey.encoded
            } catch (e: NoSuchAlgorithmException) {
                Log.e(TAG, "generateMasterKey(): $e")
                return null
            }

            // Encrypt the session key using the master key
            try {
                pbeCipher!!.init(Cipher.ENCRYPT_MODE, pbeKey, pbeParamSpec)
                cipherSessionKey = pbeCipher!!.doFinal(sessionKeyEncoded)
                status = true
            } catch (e: Exception) {
                Log.e(TAG, "encryptWithSessionKey(): $e")
            }
            if (!status) {
                return null
            }
            status = false
            val stringCipherVersion = "A"
            val bytesCipherVersion = stringCipherVersion.toByteArray()
            os.write(bytesCipherVersion, 0, bytesCipherVersion.size)
            os.write(cipherSessionKey, 0, cipherSessionKey.size)
            if (debug) {
                Log.d(TAG, "bytesCipherVersion.length: " + bytesCipherVersion.size)
            }
            if (debug) {
                Log.d(TAG, "cipherSessionKey.length: " + cipherSessionKey.size)
            }
            val tri = Trivium()
            try {
                tri.setupKey(Trivium.MODE_ENCRYPT, sessionKeyEncoded, 0)
                tri.setupNonce(sessionKeyEncoded, 10)

                // Create the byte array to hold the data
                val bytesLen = 4096 // buffer length
                val bytesIn = ByteArray(bytesLen)
                val bytesOut = ByteArray(bytesLen)
                var numRead = 0
                while (`is`.read(bytesIn, 0, bytesLen).also { numRead = it } >= 0) {
                    tri.process(bytesIn, 0, bytesOut, 0, numRead)
                    os.write(bytesOut, 0, numRead)
                }

                // Ensure all the bytes have been read in

                // Close the input stream and return bytes
                `is`.close()
                os.close()

                // Securely delete the original file:
                if (fileUri.path != null) {
                    SecureDelete.delete(File(fileUri.path!!))
                }
                status = true
            } catch (e: ESJException) {
                Log.e(TAG, "Error encrypting file", e)
            }
        } catch (e: FileNotFoundException) {
            Log.e(TAG, "File not found", e)
        } catch (e: IOException) {
            Log.e(TAG, "IO Exception", e)
        }
        return if (!status) {
            null
        } else Uri.fromFile(File(outputPath))
    }

    /**
     * @return
     */
    @Throws(CryptoHelperException::class)
    private fun getTemporaryFileName(): String {
        val randomPart: String
        try {
            // create a random session name
            randomPart = generateSalt()
        } catch (e1: NoSuchAlgorithmException) {
            e1.printStackTrace()
            val msg = "Decrypt error: " + e1.localizedMessage
            throw CryptoHelperException(msg)
        }
        return Environment.getExternalStorageDirectory().toString() + "/tmp-" + randomPart
    }

    /**
     * Dencrypt a file previously encrypted with
     * encryptFileWithSessionKey().
     * <p/>
     * Creates a new file without the .oisafe extension.
     *
     * @param ctx     Context of activity in order to store temp file
     * @param fileUri Uri to either a stream or a file to read from
     * @return If decryption is successful, returns Uri of a content
     * provider to read the plaintext file.  Upon failure,
     * return null.
     * @throws Exception
     * @author Peli
     */
    @Throws(CryptoHelperException::class)
    fun decryptFileWithSessionKey(ctx: Context, fileUri: Uri): Uri? {
        if (debug) {
            Log.d(TAG, "fileUri=$fileUri")
        }
        val contentResolver = ctx.contentResolver
        var inputPath: String? = null
        var outputPath: String? = null
        var resultUri: Uri? = null
        var result = false
        try {
            val `is`: InputStream
            if (fileUri.scheme == "file") {
                inputPath = fileUri.path
                `is` = FileInputStream(inputPath)
                if (debug) {
                    Log.d(TAG, "Decrypt: Input from $inputPath")
                }
                if (inputPath!!.endsWith(OISAFE_EXTENSION)) {
                    outputPath = inputPath.substring(0, inputPath.length - OISAFE_EXTENSION.length)
                }
            } else {
                `is` = contentResolver.openInputStream(fileUri)!!
                if (debug) {
                    Log.d(TAG, "Decrypt: Input from $fileUri")
                }
            }
            if (outputPath == null) {
                outputPath = getTemporaryFileName()
            }
            val os = FileOutputStream(outputPath)

            // after writing the decrypted content to a temporary file,
            // pass back a Uri that can be used to read back the contents
            resultUri = Uri.fromFile(File(outputPath))
            result = decryptStreamWithSessionKey(`is`, os)

            // Close the input stream
            `is`.close()
            os.close()
        } catch (e: FileNotFoundException) {
            Log.e(TAG, "File not found", e)
        } catch (e: IOException) {
            Log.e(TAG, "IOException", e)
        } catch (e: IllegalArgumentException) {
            Log.e(TAG, "IllegalArgumentException", e)
        }
        if (result) {
            // Successful
            // Securely delete the original file:
            if (inputPath != null) {
                SecureDelete.delete(File(inputPath!!))
            }
        } else {
            resultUri = null
            // Unsuccessful. Clean up
        }
        return resultUri
    }

    /**
     * Dencrypt a file previously encrypted with
     * encryptFileWithSessionKey().
     * <p/>
     * The original file is not modified
     *
     * @param ctx     Context of activity in order to store temp file
     * @param fileUri Uri to either a stream or a file to read from
     * @return If decryption is successful, returns Uri of a content
     * provider to read the plaintext file.  Upon failure,
     * return null.
     * @throws Exception
     * @author Peli
     */
    @Throws(CryptoHelperException::class)
    fun decryptFileWithSessionKeyThroughContentProvider(ctx: Context, fileUri: Uri): Uri? {
        if (debug) {
            Log.d(TAG, "fileUri=$fileUri")
        }
        val contentResolver = ctx.contentResolver
        var sessionFile = ""
        var resultUri: Uri? = null
        var result = false
        try {
            val `is`: InputStream
            if (fileUri.scheme == "file") {
                `is` = FileInputStream(fileUri.path)
                if (debug) {
                    Log.d(TAG, "Decrypt: Input from " + fileUri.path)
                }
            } else {
                `is` = contentResolver.openInputStream(fileUri)!!
                if (debug) {
                    Log.d(TAG, "Decrypt: Input from $fileUri")
                }
            }
            val os: FileOutputStream
            val decryptSession: String
            try {
                // create a random session name
                decryptSession = generateSalt()
            } catch (e1: NoSuchAlgorithmException) {
                e1.printStackTrace()
                val msg = "Decrypt error: " + e1.localizedMessage
                throw CryptoHelperException(msg)
            }
            sessionFile = CryptoContentProvider.SESSION_FILE + "." + decryptSession
            if (debug) {
                Log.d(TAG, "Decrypt: Output to $sessionFile")
            }

            // openFileOutput creates a file in /data/data/{packagename}/files/
            os = ctx.openFileOutput(sessionFile, Context.MODE_PRIVATE)

            // after writing the decrypted content to a temporary file,
            // pass back a Uri that can be used to read back the contents
            resultUri = Uri.withAppendedPath(CryptoContentProvider.CONTENT_URI, "decrypt/$decryptSession")
            result = decryptStreamWithSessionKey(`is`, os)

            // Close the input stream
            `is`.close()
            os.close()
        } catch (e: FileNotFoundException) {
            Log.e(TAG, "File not found", e)
        } catch (e: IOException) {
            Log.e(TAG, "IOException", e)
        }
        if (!result) {
            resultUri = null

            // Unsuccessful. Clean up
            ctx.deleteFile(sessionFile)
        }
        return resultUri
    }

    /**
     * Unencrypt a file previously encrypted with
     * encryptFileWithSessionKey().
     *
     * @param is                 a stream to read from
     * @param os                 where to write the decrypted stream
     * @return True if successful, otherwise false.
     * @throws Exception
     * @author Peli
     */
    @Throws(CryptoHelperException::class)
    fun decryptStreamWithSessionKey(`is`: InputStream, os: OutputStream): Boolean {
        if (debug) {
            Log.d(TAG, "decryptStreamWithSessionKey")
        }
        status = false // assume failure
        if (password == null) {
            val msg = "Must call setPassword before running decrypt."
            throw CryptoHelperException(msg)
        }
        try {
            var numReadTotal = 0
            var numRead = 0
            val byteCipherVersion = ByteArray(1)
            while (`is`.read(
                    byteCipherVersion, numRead,
                    byteCipherVersion.size - numRead
                ).also { numRead = it } >= 0 && numReadTotal < byteCipherVersion.size
            ) {
                if (debug) {
                    Log.d(TAG, "read bytes: $numRead")
                }
                numReadTotal += numRead
            }
            val cipherVersion = String(byteCipherVersion)
            var byteCipherSessionKey: ByteArray? = null

            // Split cipher into session key and text
            try {
                if (debug) {
                    Log.d(TAG, "cipherVersion : $cipherVersion")
                }
                if (cipherVersion == "A") {
                    numRead = 0
                    numReadTotal = 0
                    byteCipherSessionKey = ByteArray(48)
                    // Read the first few bytes that contain the encrypted key
                    while (`is`.read(
                            byteCipherSessionKey, numRead,
                            byteCipherSessionKey!!.size - numRead
                        ).also { numRead = it } >= 0 && numReadTotal < byteCipherSessionKey!!.size
                    ) {
                        if (debug) {
                            Log.d(TAG, "read bytes sessionKey: $numRead")
                        }
                        numReadTotal += numRead
                    }
                } else {
                    Log.e(TAG, "Unknown cipher version$cipherVersion")
                    return false
                }
            } catch (e: IndexOutOfBoundsException) {
                Log.e(TAG, "Invalid ciphertext (with session key)")
                return false
            }

            // Decrypt the session key
            var byteSessionKey = ByteArray(0)
            try {
                pbeCipher!!.init(Cipher.DECRYPT_MODE, pbeKey, pbeParamSpec)
                byteSessionKey = pbeCipher!!.doFinal(byteCipherSessionKey)
                status = true
            } catch (e: Exception) {
                Log.e(TAG, "decrypt(): $e")
            }

            // Now decrypt the message
            val tri = Trivium()
            try {
                tri.setupKey(Trivium.MODE_DECRYPT, byteSessionKey, 0)
                tri.setupNonce(byteSessionKey, 10)

                // Create the byte array to hold the data
                val bytesLen = 4096 // buffer length
                val bytesIn = ByteArray(bytesLen)
                val bytesOut = ByteArray(bytesLen)
                var offset = 0
                numRead = 0
                while (`is`.read(bytesIn, 0, bytesLen).also { numRead = it } >= 0) {
                    tri.process(bytesIn, 0, bytesOut, 0, numRead)
                    os.write(bytesOut, 0, numRead)
                    offset += numRead
                }

                // Ensure all the bytes have been read in
                if (offset < `is`.available()) {
                    throw IOException("Could not completely read file ")
                }
                status = true
            } catch (e: ESJException) {
                Log.e(TAG, "Error decrypting file", e)
            }
        } catch (e: IOException) {
            Log.e(TAG, "IOException", e)
        }
        return status
    }

    companion object {
        private const val debug = false
        private const val TAG = "CryptoHelper"
        const val OISAFE_EXTENSION = ".oisafe"


        private var pbeKeySpec: PBEKeySpec? = null

        private var pbeParamSpec: PBEParameterSpec? = null

        private var keyFac: SecretKeyFactory? = null
        const val EncryptionMedium = 1
        const val EncryptionStrong = 2

        private var desAlgorithm = "DES"

        private var password: String? = null

        private var pbeKey: SecretKey? = null

        private var pbeCipher: Cipher? = null

        private var salt: ByteArray? = null
        private const val count = 20

        /**
         * Generate a random salt for use with the cipher.
         *
         * @return String version of the 8 byte salt
         * @author Randy McEoin
         */
        @JvmStatic
        @Throws(NoSuchAlgorithmException::class)
        fun generateSalt(): String {
            val salt = ByteArray(8)
            val sr: SecureRandom
            try {
                sr = SecureRandom.getInstance("SHA1PRNG")
                sr.nextBytes(salt)
                if (debug) {
                    Log.d(TAG, "generateSalt: salt=$salt")
                }
            } catch (e: NoSuchAlgorithmException) {
                e.printStackTrace()
                throw e
            }
            return toHexString(salt)
        }

        /**
         * @return null if failure, otherwise hex string version of key
         * @author Isaac Potoczny-Jones
         */
        @JvmStatic
        @Throws(NoSuchAlgorithmException::class)
        fun generateMasterKey(): String {
            try {
                val keygen: KeyGenerator
                keygen = KeyGenerator.getInstance("AES")
                keygen.init(256)
                val genDesKey = keygen.generateKey()
                return toHexString(genDesKey.encoded)
            } catch (e: NoSuchAlgorithmException) {
                Log.e(TAG, "generateMasterKey(): $e")
                throw e
            }
        }

        /**
         * @param message
         * @return MD5 digest of message in a byte array
         * @throws NoSuchAlgorithmException
         * @throws IOException
         */
        @JvmStatic
        fun md5String(message: String): ByteArray? {
            val input = message.toByteArray()
            var hash: MessageDigest?
            var bIn: ByteArrayInputStream? = null
            var dIn: DigestInputStream? = null
            try {
                hash = MessageDigest.getInstance("MD5")
                bIn = ByteArrayInputStream(input)
                dIn = DigestInputStream(bIn, hash)
                for (i in input.indices) {
                    dIn.read()
                }
            } catch (e: NoSuchAlgorithmException) {
                Log.e(TAG, "md5String(): $e")
                return null
            } catch (e: IOException) {
                Log.e(TAG, "md5String(): $e")
                return null
            }
            return dIn!!.messageDigest.digest()
        }

        /**
         * @param bytes
         * @return String version in Hex format of input byte array
         */
        @JvmStatic
        fun toHexString(bytes: ByteArray): String {
            val retString = StringBuffer()
            for (i in bytes.indices) {
                retString.append(
                    Integer
                        .toHexString(0x0100 + (bytes[i].toInt() and 0x00FF))
                        .substring(1)
                )
            }
            return retString.toString()
        }

        @JvmStatic
        fun hexStringToBytes(hex: String): ByteArray {
            val bytes = ByteArray(hex.length / 2)
            var j = 0
            var i = 0
            while (i < hex.length) {
                try {
                    val hexByte = hex.substring(i, i + 2)
                    val k = Integer.decode("0x$hexByte")
                    bytes[j++] = k.toByte()
                } catch (e: NumberFormatException) {
                    Log.i(TAG, e.localizedMessage!!)
                    return bytes
                } catch (e: StringIndexOutOfBoundsException) {
                    Log.i(TAG, "StringIndexOutOfBoundsException")
                    return bytes
                }
                i += 2
            }
            return bytes
        }
    }
}
